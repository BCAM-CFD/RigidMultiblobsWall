# Mapping swimmers to slip-driven swimmers
In this example we provide some utility codes to compute the optimum slip to map any swimmer by slip-driven swimmers.

The theory is described in the paper

1. **Add title**, H. Gidituri, G. Kabacaoglu, M. Ellero and F. Balboa Usabiaga. Add link.


## 1. Compute squirmer slip
The utility code `squirmer_slip_generation.py` generates the slip on a spherical squirmer given by the formula

```
v_theta = B1 * sin(theta) + 0.5 * B2 * sin(2 * theta),
```

where `theta` is the polar angle on the squirmer surface.


## 2. Compute flow from slip-driven swimmers
We provide the utility code `compute_flow.py` that computes the flow on a shell generated by a slip-driven swimmer.


## 3. Compute optimum slip
The code `compute_slip_from_flow.py` computes the optimum slip to map another swimmer, flagellated or not.
The main inputs of the code are swimming velocity and flow generated on a shell by the original swimmer.

## 4. Compute velocity and flow from flagellated a swimmer
We provide input files to run a simulation with a single flagellated bacteria and compute the generated flow on a shell
discretized with a Chebyshev-Fourier grid and a rectangular grid.

To use this example it is necessary to fiddle with the code a little bit.
The steps to run the example are:

1. We save the flow in a rectangular grid using the `vtk` format so it can be postprocessed with other software such as `VisIt` or `paraview`.
It is necessary to save the `C` code in `RigidMultiblobsWall/visit/`. You will need to edit the `Makefile` in that folder.

2. You need to edit the code slightly so the code calls the functions that compute the flow during the simulation.
Add the code in the file `RigidMultiblobsWall/multi_bodies/examples/mapping/snippet.py` to the file
`RigidMultiblobsWall/quaternion_integrator/quaternion_integrator_multi_bodies.py` in the function `articulated_deterministic_forward_euler`
after the velocity of the swimmer has been calculated, i.e. around the line `1584`.
Be careful to use the right indentation!

3. Copy the file `RigidMultiblobsWall/multi_bodies/multi_bodies.py` to this folder.
And add the option `integrator.plot_velocity_field_shell = multi_bodies_functions.plot_velocity_field_shell` around the line `1250`.

4. Run the flagellated simulation. Create the output folder `mkdir data` and run the code as

```
python multi_bodies.py  --input-file inputfile_flagellated.dat
```

5. To compute the slip that maps the average flow generated by the flagellated swimmer we need the average velocity and flow.
The average velocity can be calculated with the code `get_final_speed_Higdon.py`.
The average flow on the shell with the code `average_files_sphere.py`.
Then you can compute the optimum slip as explained in Sec. 3.
You will need to edit the inputs of `compute_slip_from_flow.py`.
As a vertex file you can use the model `Structures/bacteria_rigid.shell_N_162_flagellum_L_10_alpha_0.35_d_0.262_shift_1.262.vertex`.

6. Once the optimum slip is computed you can run a simulation for an active slip driven swimmer as

```
python multi_bodies.py  --input-file inputfile_slip.dat
```

7. Once the flow in a rectangular grid has been computed for both flagellated and slip driven swimmers you can compute their differences.
First, compute the average flows using the code `average_vtk.py`.
Then, compute the difference using `difference_vtk.py`.
Finally, you can plot the difference with a postprocessing software such as `VisIt` or `paraview`.










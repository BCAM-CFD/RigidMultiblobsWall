import sys
import numpy as np

class ConstrainedIntegrator(object):
  """A class intended to test out temporal integration schemes
  for constrained diffusion. """

  def __init__(self, surface_function, mobility, scheme, initial_position):
    """ Initialize  the integrator object, it needs a surface parameterization,
    a timestepping scheme, and a Mobility Matrix.

    args
      scheme:            string - must be one of "OTTINGER" or "RFD".  OTTINGER indicates
                           an unconstrained step that is projected back to the surface.
                           RFD gives a projected step using the Random Finite Difference to
                           generate the drift.
      surface_function:  function - takes the coordinates and returns the value of 
                           the constraint function.  
                           The constraint is such that surface_function(x) = 0.
      mobility:          matrix of floats - mobility matrix.  Stored as an array of arrays
                           with the first index representing the row. Must be a square matrix.
      initial_position:  array of floats - initial position of the system.  Must be of
                           the same dimension as the mobility matrix, and we must have
                           surface_function(initial_position) = 0.
    """
    self.surface_function = surface_function
    self.mobility = mobility
    self.dim = len(mobility)
    for k in range(self.dim):
      if len(self.mobility[k]) != self.dim:
        print "Mobility Matrix must be square.  # rows is ", self.dim, 
        print " # Columns is ", len(self.mobility[k])
        sys.exit()

    self.current_time = 0.

    if (len(initial_position) == self.dim and 
        self.surface_function(initial_position) == 0.):
      self.position = initial_position
    else:
      raise ValueError("Initial position is either the wrong dimension or"
                        " is not on the constraint.")
      
    if scheme not in ["RFD", "OTTINGER"]:
      print "Only RFD and Euler Schemes are implemented"
      raise NotImplementedError("Only RFD and Euler schemes are implemented")
    else:
      self.scheme = scheme
    
  def TimeStep(self, dt):
    """ Step from current time to next time with timestep of size dt.
     args
       dt: float - time step size.
     """
    if self.scheme == "RFD":
      self.RFDTimeStep(dt)
    elif self.scheme == "OTTINGER":
      self.OttingerTimeStep(dt)
    else:
      print "Should not get here in TimeStep."
      sys.exit()

  def ApplyMobility(self, force):
    """ Apply the mobility to a force in order to generate velocity.
    
    args
      force:    array of floats - input force to apply mobility to.
      
    output
      velocity: array of floats - velocity generated by force on particle.
                     velocity = mobility*force.
    """
    velocity = np.zeros(self.dim)
    for j in range(self.dim):
      for k in range(self.dim):
        velocity[j] += self.mobility[j][k]*force[k]
    return velocity

  def ApplyProjection(self, vector):
    """ Apply the P_m projection to a vector. 
    
    output
      projected_vector: array of floats - vector after being projected. 
    """
    projection = self.ProjectionMatrix()
    projected_vector = np.zeros(self.dim)
    for j in range(self.dim):
      for k in range(self.dim):
        projected_vector[j] += projection[j][k]*vector[k]
    return projected_vector
        
  def OttingerTimeStep(self, dt):
    """ Take a step of the Ottinger scheme """
    pass

  def RFDTimeStep(self, dt):
    """ Take a step of the RFD scheme """
    Wtilde = np.random.normal(0.0, 1.0, self.dim)
    predictor_position = zeros(self.dim)
    for k in range(self.dim):
      predictor_position[k] = self.position[k] + self.rfdelta*Wtilde[k]
      
    #For now we have no potential.
    corrector_position = zeros(self.dim)
    for k in range(

  def NormalVector(self):
    """ At the current initial position, calculate normalized gradient
    of the surface_function numerically. 

    output
      normal_vector: array of floats - normalized gradient of the surface 
                       funtion at self.position, evaluated numerically.
    """
    normal_vector = np.zeros(self.dim)
    delta = 1.0e-5
    vector_size = 0.0
    for k in range(self.dim):
      direction = np.zeros(self.dim)
      direction[k] = delta
      normal_vector[k] = ((self.surface_function(self.position + direction) - 
                          self.surface_function(self.position - direction))/
                          delta)
      vector_size += normal_vector[k]**2
    
    vector_size = np.sqrt(vector_size)
    for k in range(self.dim):
      normal_vector[k] /= vector_size
      
    return normal_vector
      
  def ProjectionMatrix(self):
    """ Calculate projection matrix, P_m = delta_ik - (Mn X n) /(n^tMn) """
    normal_vector = self.NormalVector()
    projection = [zeros(self.dim) for _ in range(self.dim)]

    # First calcualate n^t M n for denominator.
    nMn = 0.
    for j in range(self.dim):
      for k in range(self.dim):
        nMn += normal_vector[j]*self.mobility[j][k]*normal_vector[k]

    for j in range(self.dim):
      for k in range(self.dim):
        projection[j][k] = 0
        for l in range(self.dim):
          projection[j][k] += (self.mobility[j][l]*normal_vector[l]*
                               normal_vector[k])
        projection[j][k] /= nMn
        if j == k:
          projection[j][k] += 1.0

    return projection

  
        
    
